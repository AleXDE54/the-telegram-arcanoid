<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Arkanoid Mini</title>
  <script src="https://unpkg.com/@telegram-apps/sdk@7.5.0/dist/web.js"></script>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #0f0f15;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      color: white;
    }
    canvas {
      border: 1px solid #333;
      background: #000;
      display: block;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 16px;
      pointer-events: none;
      z-index: 10;
    }
    .screen {
      position: absolute;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      background: #0f0f15;
      padding: 20px;
    }
    #menu h1 {
      font-size: 32px;
      margin-bottom: 30px;
      background: linear-gradient(45deg, #4CAF50, #2196F3);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      text-align: center;
    }
    .btn {
      padding: 14px 28px;
      font-size: 18px;
      background: #2196F3;
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      margin: 8px 0;
      width: 80%;
      max-width: 300px;
      transition: background 0.2s;
    }
    .btn:hover, .btn:active { background: #1976D2; }
    .levels-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 12px;
      margin-top: 20px;
      width: 80%;
      max-width: 300px;
    }
    .level-btn {
      padding: 12px;
      background: #444;
      border: none;
      border-radius: 8px;
      color: white;
      font-weight: bold;
      cursor: pointer;
    }
    .level-btn.locked {
      background: #222;
      color: #666;
      cursor: not-allowed;
    }
    .level-btn.unlocked { background: #4CAF50; }
    .back-btn {
      margin-top: 20px;
      background: #607D8B;
    }
    .back-btn:hover { background: #546E7A; }
  </style>
</head>
<body>
  <!-- –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é -->
  <div id="menu" class="screen">
    <h1>Arkanoid Mini</h1>
    <button id="btn-levels" class="btn">–ö–∞–º–ø–∞–Ω–∏—è</button>
    <button id="btn-endless" class="btn">–ë–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Ä–µ–∂–∏–º</button>
    <div id="best-score">–õ—É—á—à–∏–π —Å—á—ë—Ç: 0</div>
  </div>

  <!-- –ú–µ–Ω—é –≤—ã–±–æ—Ä–∞ —É—Ä–æ–≤–Ω—è -->
  <div id="level-select" class="screen" style="display: none;">
    <h2>–í—ã–±–µ—Ä–∏—Ç–µ —É—Ä–æ–≤–µ–Ω—å</h2>
    <div class="levels-grid" id="levels-container"></div>
    <button id="btn-back-to-menu" class="btn back-btn">–ù–∞–∑–∞–¥</button>
  </div>

  <!-- –ò–≥—Ä–æ–≤–æ–π —ç–∫—Ä–∞–Ω -->
  <div id="game" class="screen" style="display: none;">
    <canvas id="arkanoid" width="400" height="600"></canvas>
    <div id="ui">–°—á—ë—Ç: <span id="score">0</span> | –ñ–∏–∑–Ω–∏: <span id="lives">3</span></div>
  </div>

  <script>
    // === Telegram SDK ===
    const tg = window.Telegram?.WebApp;
    tg?.ready();
    tg?.expand(); // —Ä–∞—Å—à–∏—Ä–∏—Ç—å –Ω–∞ –≤—Å—é –≤—ã—Å–æ—Ç—É

    let userId = 'guest';
    if (tg?.initDataUnsafe?.user?.id) {
      userId = String(tg.initDataUnsafe.user.id);
    }

    const saveKey = `arkanoid_${userId}`;
    let progress = JSON.parse(localStorage.getItem(saveKey) || JSON.stringify({
      bestEndlessScore: 0,
      maxLevel: 0
    }));

    // === DOM ===
    const menu = document.getElementById('menu');
    const levelSelect = document.getElementById('level-select');
    const gameDiv = document.getElementById('game');
    const canvas = document.getElementById('arkanoid');
    const ctx = canvas.getContext('2d');

    document.getElementById('best-score').innerText = `–õ—É—á—à–∏–π —Å—á—ë—Ç: ${progress.bestEndlessScore}`;

    // === –ò–≥—Ä–æ–≤–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ ===
    let gameState = 'menu';
    let score = 0;
    let lives = 3;
    let level = 1;
    let isEndless = false;

    // === –û–±—ä–µ–∫—Ç—ã ===
    const platform = {
      width: 80,
      height: 15,
      x: canvas.width / 2 - 40,
      y: canvas.height - 60, // ‚Üë –ø–æ–¥–Ω—è–ª–∏ –Ω–∞ 30px (–±—ã–ª–æ -30 ‚Üí —Ç–µ–ø–µ—Ä—å -60 –æ—Ç –Ω–∏–∑–∞)
      originalWidth: 80
    };

    const ball = {
      x: canvas.width / 2,
      y: canvas.height - 80,
      dx: 4,
      dy: -4,
      radius: 8,
      ghost: false,
      slow: false
    };

    let bricks = [];
    const brickRows = 5;
    const brickCols = 10;
    const brickWidth = 35;
    const brickHeight = 20;
    const brickPadding = 5;
    const brickOffsetTop = 60;
    const brickOffsetLeft = 30;

    const powerUps = [];
    const activeEffects = {
      bigPaddle: 0,
      slowTime: 0,
      ghostBall: 0
    };

    // === –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —É—Ä–æ–≤–Ω–µ–π ===
    function createLevel(lvl) {
      bricks = [];
      const types = ['normal', 'normal', 'normal', 'power'];
      for (let r = 0; r < brickRows; r++) {
        for (let c = 0; c < brickCols; c++) {
          let type = 'normal';
          if (lvl > 1 && Math.random() > 0.6) type = 'power';
          bricks.push({
            x: c * (brickWidth + brickPadding) + brickOffsetLeft,
            y: r * (brickHeight + brickPadding) + brickOffsetTop,
            width: brickWidth,
            height: brickHeight,
            status: true,
            type
          });
        }
      }
      if (lvl === 1) bricks.forEach(b => b.type = 'normal');
    }

    // === –ë–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Ä–µ–∂–∏–º —Å –ø–æ—Å—Ç–µ–ø–µ–Ω–Ω—ã–º —Å–ø–∞–≤–Ω–æ–º ===
    let spawnQueue = [];
    let spawnTimer = null;

    function createEndlessLevel() {
      bricks = [];
      spawnQueue = [];
      const totalBlocks = 30 + Math.min(40, Math.floor(score / 20));
      for (let i = 0; i < totalBlocks; i++) {
        const r = Math.floor(Math.random() * 6); // –¥–æ 6 —Ä—è–¥–æ–≤
        const c = Math.floor(Math.random() * brickCols);
        const chance = isEndless ? (Math.random() > 0.4 ? 'normal' : 'power') : 'normal';
        spawnQueue.push({
          x: c * (brickWidth + brickPadding) + brickOffsetLeft,
          y: r * (brickHeight + brickPadding) + brickOffsetTop,
          width: brickWidth,
          height: brickHeight,
          status: true,
          type: chance
        });
      }
      spawnNextBatch();
    }

    function spawnNextBatch() {
      if (spawnQueue.length === 0) return;
      const batch = spawnQueue.splice(0, 2 + Math.min(5, Math.floor(score / 50)));
      bricks.push(...batch);
      if (spawnQueue.length > 0) {
        spawnTimer = setTimeout(spawnNextBatch, 800);
      }
    }

    // === –ë–æ–Ω—É—Å—ã ===
    const powerUpTypes = ['big_paddle', 'slow_time', 'extra_life', 'ghost_ball'];

    function dropPowerUp(x, y) {
      if (Math.random() < 0.35) {
        const type = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
        powerUps.push({ x, y, dy: 2, type, width: 20, height: 20 });
      }
    }

    function applyPowerUp(type) {
      switch (type) {
        case 'big_paddle':
          platform.width = 140;
          activeEffects.bigPaddle = Date.now() + 5000;
          break;
        case 'slow_time':
          ball.slow = true;
          activeEffects.slowTime = Date.now() + 5000;
          break;
        case 'extra_life':
          lives++;
          break;
        case 'ghost_ball':
          ball.ghost = true;
          activeEffects.ghostBall = Date.now() + 5000;
          break;
      }
    }

    // === –ö–æ–ª–ª–∏–∑–∏–∏ ===
    function collisionDetection() {
      for (let i = 0; i < bricks.length; i++) {
        const brick = bricks[i];
        if (!brick.status) continue;
        if (
          ball.x + ball.radius > brick.x &&
          ball.x - ball.radius < brick.x + brick.width &&
          ball.y + ball.radius > brick.y &&
          ball.y - ball.radius < brick.y + brick.height
        ) {
          if (!ball.ghost) ball.dy = -ball.dy;
          brick.status = false;
          score += 10;
          if (brick.type === 'power') dropPowerUp(brick.x + brick.width / 2, brick.y + brick.height);
        }
      }
    }

    // === –≠—Ñ—Ñ–µ–∫—Ç—ã ===
    function updateEffects() {
      const now = Date.now();
      if (activeEffects.bigPaddle < now && platform.width !== platform.originalWidth) {
        platform.width = platform.originalWidth;
      }
      if (activeEffects.slowTime < now) ball.slow = false;
      if (activeEffects.ghostBall < now) ball.ghost = false;
    }

    // === –û—Ç—Ä–∏—Å–æ–≤–∫–∞ ===
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞
      ctx.fillStyle = '#4CAF50';
      ctx.fillRect(platform.x, platform.y, platform.width, platform.height);

      // –ú—è—á
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fillStyle = ball.ghost ? '#9c27b0' : '#ff5722';
      ctx.fill();
      ctx.closePath();

      // –ë–ª–æ–∫–∏
      bricks.forEach(brick => {
        if (brick.status) {
          ctx.fillStyle = brick.type === 'power' ? '#ff9800' : '#2196F3';
          ctx.fillRect(brick.x, brick.y, brick.width, brick.height);
          ctx.strokeStyle = '#fff';
          ctx.strokeRect(brick.x, brick.y, brick.width, brick.height);
        }
      });

      // –ë–æ–Ω—É—Å—ã
      for (let i = powerUps.length - 1; i >= 0; i--) {
        const pu = powerUps[i];
        pu.y += pu.dy;
        ctx.fillStyle = '#e91e63';
        ctx.fillRect(pu.x - pu.width / 2, pu.y, pu.width, pu.height);

        if (
          pu.y + pu.height > platform.y &&
          pu.x > platform.x &&
          pu.x < platform.x + platform.width
        ) {
          applyPowerUp(pu.type);
          powerUps.splice(i, 1);
        }
      }

      // UI
      document.getElementById('score').innerText = score;
      document.getElementById('lives').innerText = lives;
    }

    // === –ò–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª ===
    function update() {
      if (gameState !== 'playing') return;

      let speedFactor = ball.slow ? 0.5 : 1;
      ball.x += ball.dx * speedFactor;
      ball.y += ball.dy * speedFactor;

      // –°—Ç–µ–Ω—ã
      if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) ball.dx = -ball.dx;
      if (ball.y - ball.radius < 0) ball.dy = -ball.dy;
      if (ball.y + ball.radius > canvas.height) {
        lives--;
        if (lives <= 0) {
          endGame();
        } else {
          resetBall();
        }
      }

      // –ü–ª–∞—Ç—Ñ–æ—Ä–º–∞
      if (
        ball.y + ball.radius > platform.y &&
        ball.x > platform.x &&
        ball.x < platform.x + platform.width &&
        ball.dy > 0
      ) {
        ball.dy = -ball.dy;
        const hitPos = (ball.x - platform.x) / platform.width;
        ball.dx = 6 * (hitPos - 0.5);
      }

      collisionDetection();
      updateEffects();

      // –ü–æ–±–µ–¥–∞
      const aliveBricks = bricks.filter(b => b.status);
      if (aliveBricks.length === 0 && spawnQueue.length === 0) {
        if (isEndless) {
          score += 100;
          setTimeout(() => {
            createEndlessLevel();
          }, 800);
        } else {
          if (level >= 5) {
            alert('üèÜ –ü–æ–±–µ–¥–∞! –ö–∞–º–ø–∞–Ω–∏—è –ø—Ä–æ–π–¥–µ–Ω–∞!');
            if (level > progress.maxLevel) {
              progress.maxLevel = level;
              saveProgress();
            }
            backToMenu();
          } else {
            level++;
            setTimeout(() => {
              createLevel(level);
              resetBall();
            }, 600);
          }
        }
      }

      draw();
      requestAnimationFrame(update);
    }

    function resetBall() {
      ball.x = platform.x + platform.width / 2;
      ball.y = platform.y - ball.radius;
      ball.dx = 4;
      ball.dy = -4;
    }

    function startGame(endless = false, lvl = 1) {
      isEndless = endless;
      level = endless ? 1 : lvl;
      gameState = 'playing';
      score = 0;
      lives = 3;
      platform.x = canvas.width / 2 - platform.width / 2;

      if (endless) {
        createEndlessLevel();
      } else {
        createLevel(level);
      }

      resetBall();
      powerUps.length = 0;
      Object.keys(activeEffects).forEach(k => activeEffects[k] = 0);
      platform.width = platform.originalWidth;

      menu.style.display = 'none';
      levelSelect.style.display = 'none';
      gameDiv.style.display = 'flex';
      update();
    }

    function endGame() {
      clearTimeout(spawnTimer);
      gameState = 'menu';
      if (isEndless && score > progress.bestEndlessScore) {
        progress.bestEndlessScore = score;
        saveProgress();
        document.getElementById('best-score').innerText = `–õ—É—á—à–∏–π —Å—á—ë—Ç: ${progress.bestEndlessScore}`;
      }
      backToMenu();
      alert(`–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!\n–í–∞—à —Å—á—ë—Ç: ${score}`);
    }

    function backToMenu() {
      menu.style.display = 'flex';
      levelSelect.style.display = 'none';
      gameDiv.style.display = 'none';
    }

    function saveProgress() {
      localStorage.setItem(saveKey, JSON.stringify(progress));
    }

    // === –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ ===
    let isTouch = false;
    ['touchstart', 'mousedown'].forEach(ev => {
      canvas.addEventListener(ev, e => {
        isTouch = true;
        e.preventDefault();
      });
    });
    ['touchmove', 'mousemove'].forEach(ev => {
      canvas.addEventListener(ev, e => {
        if (!isTouch) return;
        const rect = canvas.getBoundingClientRect();
        const clientX = ev === 'touchmove' ? e.touches[0].clientX : e.clientX;
        const x = clientX - rect.left;
        platform.x = x - platform.width / 2;
        platform.x = Math.max(0, Math.min(canvas.width - platform.width, platform.x));
        e.preventDefault();
      });
    });
    ['touchend', 'mouseup', 'mouseleave'].forEach(ev => {
      canvas.addEventListener(ev, () => isTouch = false);
    });

    // === –ú–µ–Ω—é —É—Ä–æ–≤–Ω–µ–π ===
    function renderLevelSelect() {
      const container = document.getElementById('levels-container');
      container.innerHTML = '';
      for (let i = 1; i <= 5; i++) {
        const btn = document.createElement('button');
        btn.className = `level-btn ${i <= progress.maxLevel + 1 ? 'unlocked' : 'locked'}`;
        btn.innerText = i;
        if (i <= progress.maxLevel + 1) {
          btn.onclick = () => startGame(false, i);
        }
        container.appendChild(btn);
      }
    }

    // === –°–æ–±—ã—Ç–∏—è –∫–Ω–æ–ø–æ–∫ ===
    document.getElementById('btn-levels').onclick = () => {
      renderLevelSelect();
      menu.style.display = 'none';
      levelSelect.style.display = 'flex';
    };
    document.getElementById('btn-endless').onclick = () => startGame(true);
    document.getElementById('btn-back-to-menu').onclick = backToMenu;

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    document.getElementById('best-score').innerText = `–õ—É—á—à–∏–π —Å—á—ë—Ç: ${progress.bestEndlessScore}`;
  </script>
</body>
</html>
