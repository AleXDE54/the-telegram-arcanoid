<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Arcanoid Telegram</title>
<script src="https://telegram.org/js/telegram-web-app.js?59"></script>
<style>
  html, body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    font-family: Arial, sans-serif;
    background-color: #1e2732;
    color: white;
    user-select: none;
  }
  canvas {
    display: block;
    background-color: #1e2732;
  }
  #ui {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    padding: 6px 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 18px;
    color: white;
    z-index: 2;
  }
  #pauseBtn {
    cursor: pointer;
    background: none;
    border: none;
    color: white;
    font-size: 22px;
  }
  #menu {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(20, 30, 40, 0.95);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    gap: 20px;
    z-index: 3;
  }
  #menu h1 {
    font-size: 48px;
    font-weight: bold;
    color: white;
  }
  #playBtn {
    font-size: 22px;
    padding: 10px 30px;
    border-radius: 12px;
    border: none;
    cursor: pointer;
    background-color: #24A1DE;
    color: white;
    transition: 0.2s;
  }
  #playBtn:hover {
    transform: scale(1.05);
    background-color: #2bb6f3;
  }
</style>
</head>
<body>
<div id="ui" style="display:none;">
  <div>Очки: <span id="score">0</span> | Жизни: <span id="lives">3</span></div>
  <button id="pauseBtn">⏸</button>
</div>

<div id="menu">
  <h1>Arcanoid</h1>
  <button id="playBtn">Play</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreElem = document.getElementById('score');
const livesElem = document.getElementById('lives');
const ui = document.getElementById('ui');
const menu = document.getElementById('menu');
const playBtn = document.getElementById('playBtn');
const pauseBtn = document.getElementById('pauseBtn');

// Telegram theme colors
let theme = Telegram?.WebApp?.themeParams || {};
let mainColor = theme.button_color || "#24A1DE";
let bgColor = theme.bg_color || "#1e2732";
let textColor = theme.text_color || "#ffffff";

document.body.style.backgroundColor = bgColor;
canvas.style.backgroundColor = bgColor;
menu.style.backgroundColor = bgColor;
menu.querySelector("h1").style.color = textColor;
ui.style.color = textColor;
pauseBtn.style.color = textColor;
playBtn.style.backgroundColor = mainColor;

// Canvas size
let W = (canvas.width = window.innerWidth);
let H = (canvas.height = window.innerHeight);

// === Игровые переменные ===
let bottomOffset = 75; // ≈2 см отступ для пальца
let paddleWidth = 150;
let paddleHeight = 15;
let paddleX = W / 2 - paddleWidth / 2;
let paddleSpeed = 0;
let oldPaddleX = paddleX;

let ballRadius = 10;
let ballX = W / 2;
let ballY = H / 2;
let dx = 3, dy = -4;

let rightPressed = false;
let leftPressed = false;
let touchX = null;
let isMoving = false;

let score = 0;
let lives = 3;
let paused = false;
let gameRunning = false;

// Уровни
let level = 1;
let bricks = [];
let brickRows = 4;
let brickCols = 7;
let brickWidth = 80;
let brickHeight = 25;
let brickPadding = 10;
let brickOffsetTop = 70;
let brickOffsetLeft = 30;

// ============================
function initBricks() {
  bricks = [];
  for (let r = 0; r < brickRows; r++) {
    for (let c = 0; c < brickCols; c++) {
      const brickX = brickOffsetLeft + c * (brickWidth + brickPadding);
      const brickY = brickOffsetTop + r * (brickHeight + brickPadding);
      bricks.push({ x: brickX, y: brickY, w: brickWidth, h: brickHeight, alive: true });
    }
  }
}

// ============================
function drawPaddle() {
  ctx.fillStyle = mainColor;
  ctx.beginPath();
  ctx.roundRect(paddleX, H - bottomOffset - paddleHeight, paddleWidth, paddleHeight, 8);
  ctx.fill();
}

function drawBall() {
  ctx.beginPath();
  ctx.arc(ballX, ballY, ballRadius, 0, Math.PI * 2);
  ctx.fillStyle = mainColor;
  ctx.fill();
}

function drawBricks() {
  ctx.fillStyle = mainColor;
  bricks.forEach(b => {
    if (b.alive) {
      ctx.beginPath();
      ctx.roundRect(b.x, b.y, b.w, b.h, 6);
      ctx.fill();
    }
  });
}

// ============================
function draw() {
  ctx.clearRect(0, 0, W, H);
  drawBricks();
  drawPaddle();
  drawBall();
}

function update() {
  if (paused || !gameRunning) return;

  oldPaddleX = paddleX;

  if (rightPressed) paddleX += 6;
  if (leftPressed) paddleX -= 6;
  if (touchX !== null) {
    paddleX += (touchX - (paddleX + paddleWidth / 2)) * 0.25;
  }

  paddleSpeed = paddleX - oldPaddleX;
  paddleX = Math.max(0, Math.min(W - paddleWidth, paddleX));

  if (!isMoving) {
    ballX = paddleX + paddleWidth / 2;
    ballY = H - bottomOffset - paddleHeight - ballRadius - 2;
    return;
  }

  ballX += dx;
  ballY += dy;

  // Отражения от стен
  if (ballX + ballRadius > W || ballX - ballRadius < 0) dx = -dx;
  if (ballY - ballRadius < 0) dy = -dy;

  // Коллизия с платформой
  const paddleTop = H - bottomOffset - paddleHeight;
  if (ballY + ballRadius >= paddleTop && ballY + ballRadius <= paddleTop + 10) {
    if (ballX > paddleX && ballX < paddleX + paddleWidth) {
      ballY = paddleTop - ballRadius;
      const impact = (ballX - (paddleX + paddleWidth / 2)) / (paddleWidth / 2);
      const speedMag = Math.max(3, Math.hypot(dx, dy));
      const maxAngle = (75 * Math.PI) / 180;
      const angle = impact * maxAngle;
      dx = speedMag * Math.sin(angle) + paddleSpeed * 0.05;
      dy = -Math.abs(speedMag * Math.cos(angle));
      const norm = Math.hypot(dx, dy);
      dx = (dx / norm) * speedMag;
      dy = (dy / norm) * speedMag;
    }
  }

  // Столкновения с блоками
  bricks.forEach(b => {
    if (!b.alive) return;
    if (
      ballX + ballRadius > b.x &&
      ballX - ballRadius < b.x + b.w &&
      ballY + ballRadius > b.y &&
      ballY - ballRadius < b.y + b.h
    ) {
      const overlapX = Math.min(ballX + ballRadius - b.x, b.x + b.w - (ballX - ballRadius));
      const overlapY = Math.min(ballY + ballRadius - b.y, b.y + b.h - (ballY - ballRadius));
      if (overlapX < overlapY) dx = -dx;
      else dy = -dy;

      b.alive = false;
      const pts = 5 + Math.floor(Math.random() * 11);
      score += pts;
      scoreElem.textContent = score;
    }
  });

  // Потеря жизни
  if (ballY - ballRadius > H) {
    lives--;
    livesElem.textContent = lives;
    if (lives <= 0) gameOver();
    else resetBall();
  }

  // Победа
  if (bricks.every(b => !b.alive)) nextLevel();
}

function resetBall() {
  isMoving = false;
  ballX = paddleX + paddleWidth / 2;
  ballY = H - bottomOffset - paddleHeight - ballRadius - 2;
  dx = 3;
  dy = -4;
}

function gameOver() {
  gameRunning = false;
  ui.style.display = "none";
  menu.style.display = "flex";
  menu.querySelector("h1").textContent = "Game Over";
  playBtn.textContent = "Play Again";
}

function nextLevel() {
  level++;
  brickRows++;
  resetBall();
  initBricks();
}

// ============================
document.addEventListener("keydown", e => {
  if (e.key === "ArrowRight") rightPressed = true;
  if (e.key === "ArrowLeft") leftPressed = true;
});
document.addEventListener("keyup", e => {
  if (e.key === "ArrowRight") rightPressed = false;
  if (e.key === "ArrowLeft") leftPressed = false;
});
canvas.addEventListener("touchstart", e => {
  touchX = e.touches[0].clientX;
  isMoving = true;
});
canvas.addEventListener("touchmove", e => {
  touchX = e.touches[0].clientX;
  isMoving = true;
});
canvas.addEventListener("touchend", () => {
  touchX = null;
  isMoving = false;
});
pauseBtn.addEventListener("click", () => paused = !paused);
playBtn.addEventListener("click", startGame);

function startGame() {
  menu.style.display = "none";
  ui.style.display = "flex";
  score = 0;
  lives = 3;
  level = 1;
  initBricks();
  resetBall();
  gameRunning = true;
  paused = false;
  menu.querySelector("h1").textContent = "Arcanoid";
  playBtn.textContent = "Play";
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

initBricks();
loop();
</script>
</body>
</html>
